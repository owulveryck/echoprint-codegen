package main

import (
	"bytes"
	"compress/zlib"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strconv"
)

// EchoNest holds the structure as generated by echonest-print
type EchoNest struct {
	Metadata struct {
		Artist         string  `json:"artist"`
		Release        string  `json:"release"`
		Title          string  `json:"title"`
		Genre          string  `json:"genre"`
		Bitrate        int     `json:"bitrate"`
		SampleRate     int     `json:"sample_rate"`
		Duration       int     `json:"duration"`
		Filename       string  `json:"filename"`
		SamplesDecoded int     `json:"samples_decoded"`
		GivenDuration  int     `json:"given_duration"`
		StartOffset    int     `json:"start_offset"`
		Version        float64 `json:"version"`
		CodegenTime    float64 `json:"codegen_time"`
		DecodeTime     float64 `json:"decode_time"`
	} `json:"metadata"`
	CodeCount int    `json:"code_count"`
	Code      string `json:"code"`
	Tag       int    `json:"tag"`
}

func main() {
	var fps []EchoNest

	err := json.NewDecoder(os.Stdin).Decode(&fps)

	if err != nil {
		log.Fatal("error:", err)
	}
	for _, fp := range fps {
		data, err := base64.StdEncoding.DecodeString(fp.Code)
		if err != nil {
			log.Fatal("error:", err)
			return
		}
		var b bytes.Buffer
		b.Write(data)
		r, err := zlib.NewReader(&b)
		if err != nil {
			log.Fatal("error:", err)
			return
		}

		buf := new(bytes.Buffer)
		buf.ReadFrom(r)
		s := buf.String()
		codes, times, err := decode(s)
		for i := range times {
			fmt.Printf("%v\n", codes[i])
		}

		r.Close()
	}
}

// decode takes an uncompressed code string consisting of zero-padded
// fixed-width sorted hex integers (time values followed by hash codes) and
// converts it to a pair of uint code/time arrays
func decode(fp string) ([]uint32, []uint32, error) {

	// 5 hex bytes for hash, 5 hex bytes for time (40 bits per tuple)
	tupleCount := len(fp) / 5
	length := tupleCount / 2
	codes := make([]uint32, length)
	times := make([]uint32, length)

	var offset int
	var conv uint64
	var err error
	var i int

	// first half of string (time values)
	for ; i < length; i++ {
		offset = i * 5
		conv, err = strconv.ParseUint(fp[offset:offset+5], 16, 32)
		if err != nil {
			return nil, nil, err
		}
		times[i] = uint32(conv)
	}

	// second half of string (code values)
	for ; i < tupleCount; i++ {
		offset = i * 5
		conv, err = strconv.ParseUint(fp[offset:offset+5], 16, 32)
		if err != nil {
			return nil, nil, err
		}
		codes[i-length] = uint32(conv)
	}

	return codes, times, nil
}
